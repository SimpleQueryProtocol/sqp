/*
 * Copyright 2015 by Rothmeyer Consulting (http://www.rothmeyer.com/)
 * Author: Stefan Burnicki <stefan.burnicki@burnicki.net>
 *
 * This file is part of SQP.
 *
 * SQP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License.
 *
 * SQP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with SQP.  If not, see <http://www.gnu.org/licenses/>.
 */

package io.sqp.transbase;

import io.sqp.backend.exceptions.TransactionFinishFailedException;
import transbase.tbx.TBFeatures;
import transbase.tbx.TBXTransactionIf;
import transbase.tbx.java.TBXJavaTransaction;

import java.sql.SQLException;

/**
 * @author Stefan Burnicki
 */
public class Transaction {
    // Idea from transbase.jdbc.Connection
    public enum CommitType {
        /**
         * Used for calls generated by the execution of queries, that deliver a result set. Those queries
         * only try to commit before the statement.
         */
        SELECT_QUERY,

        /**
         * Used for calls generated by the execution of update queries. Those queries try to commit before
         * and after the statement.
         */
        UPDATE_QUERY,

        /**
         * Used for calls to tryAutoCommit, triggered by the closing procedure of a Cursor.
         */
        CLOSE_CURSOR
    }

    public enum AutoCommit {
        ON(TBXTransactionIf.AUTOCOMMIT_ON),
        STRICT(TBXTransactionIf.AUTOCOMMIT_STRICT),
        STRICT_ON_UPDATES(TBXTransactionIf.AUTOCOMMIT_STRICT_ON_UPDATES),
        OFF(TBXTransactionIf.AUTOCOMMIT_OFF);

        public final short Value;

        AutoCommit(short value) {
            Value = value;
        }
    }

    private Connection _connection;
    private TBXTransactionIf _transaction;
    private AutoCommit _autoCommitMode;
    private AutoCommit _defaultAutoCommitMode;
    private short _consistency;

    public Transaction(Connection connection) throws TransactionFinishFailedException {
        _consistency = TBXTransactionIf.CONS_3;
        _connection = connection;
        if (_connection.getTBXConnection().supportsFeature(TBFeatures.AUTOCOMMIT)) {
            _autoCommitMode = AutoCommit.ON;
        } else {
            // TODO: we could make this configurable in the future
            _autoCommitMode = AutoCommit.STRICT;
        }
        _defaultAutoCommitMode = _autoCommitMode;
        try {
            _transaction = new TBXJavaTransaction(_consistency, _autoCommitMode.Value);
        } catch (SQLException e) {
            throw new TransactionFinishFailedException("Failed to create a transaction object.", e);
        }
    }

    public void commit() throws TransactionFinishFailedException {
        if (!getAutoCommit()) {
            // TODO: need to close cursors?
        }
        try {
            _transaction.commit();
            _transaction = _transaction.spawn(_consistency, _autoCommitMode.Value);
        } catch (SQLException e) {
            throw new TransactionFinishFailedException(true, e);
        }
    }

    public void rollback() throws TransactionFinishFailedException {
        if(getAutoCommit()) {
            return;
        }
        try {
            _transaction.abort();
            _transaction = _transaction.spawn(_consistency, _autoCommitMode.Value);
        } catch (SQLException e) {
            throw new TransactionFinishFailedException(false, e);
        }
    }

    public void tryAutoCommit(CommitType commitType) throws TransactionFinishFailedException {
        int taState;
        try {
            taState = _transaction.getTaState();
        } catch (SQLException e) {
            throw new TransactionFinishFailedException(true, e);
        }
        if (_autoCommitMode != AutoCommit.OFF &&
            taState == TBXTransactionIf.TA_ACTIVE &&
            needsCommit(commitType)) {
            commit();
        }
    }

    public boolean getAutoCommit() {
        return _autoCommitMode != AutoCommit.OFF;
    }

    public void setAutoCommit(boolean enable) throws TransactionFinishFailedException {
        // make sure that we actually need to change the value
        if ((_autoCommitMode == AutoCommit.OFF && !enable) ||
            (_autoCommitMode != AutoCommit.OFF && enable)) {
            return;
        }
        // if we enable it, we need to commit the current transaction
        if (_autoCommitMode == AutoCommit.OFF) {
            try {
                _transaction.commit();
            } catch (SQLException e) {
                throw new TransactionFinishFailedException(true, e);
            }
        }
        // set the value, spawn a new transaction
         _autoCommitMode = enable ? _defaultAutoCommitMode : AutoCommit.OFF;
        try {
            _transaction = _transaction.spawn(_consistency, _autoCommitMode.Value);
        } catch (SQLException e) {
            throw new TransactionFinishFailedException("Failed to spawn a new transaction.", e);
        }
    }

    public TBXTransactionIf getTBXTransaction() {
        return _transaction;
    }

    private boolean needsCommit(CommitType commitType) {
        return _autoCommitMode == AutoCommit.STRICT ||
               (commitType == CommitType.CLOSE_CURSOR && _connection.getNumOpenCursors() == 0) ||
               (commitType == CommitType.UPDATE_QUERY && _autoCommitMode == AutoCommit.STRICT_ON_UPDATES);
    }
}
